'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.createPathParser = createPathParser;
function createPathParser(junctionSet) {
  var tree = {};
  var queue = [[junctionSet.$$junctionSetMeta, tree, []]];
  while (queue.length) {
    var _queue$shift = queue.shift(),
        _queue$shift2 = _slicedToArray(_queue$shift, 3),
        junctionSetMetaNode = _queue$shift2[0],
        treeNode = _queue$shift2[1],
        junctionPath = _queue$shift2[2];

    var primaryJunctionKey = junctionSetMetaNode.primaryKey;

    if (primaryJunctionKey) {
      var primaryJunction = junctionSetMetaNode.junctions[primaryJunctionKey];
      var branchKeys = primaryJunction.$$junctionMeta.branchKeys;
      var nextJunctionPath = junctionPath.concat(primaryJunctionKey);

      for (var i = 0, len = branchKeys.length; i < len; i++) {
        var branch = primaryJunction[branchKeys[i]];
        var parts = branch.pattern.parts;
        var finalIndex = parts.length - 1;
        var intermediateNode = treeNode;
        for (var j = 0; j < finalIndex; j++) {
          var part = parts[j] || ':';
          if (!intermediateNode[part]) {
            intermediateNode[part] = { childNode: {} };
          } else if (intermediateNode[part].branch) {
            throw new Error('Conflicting paths');
          }
          intermediateNode = intermediateNode[part].childNode;
        }
        var finalPart = parts[finalIndex] || ':';
        var childNode = {};
        intermediateNode[finalPart] = {
          branch: branch,
          childNode: childNode,
          junctionPath: nextJunctionPath.join('#')
        };
        if (branch.next) {
          queue.push([branch.next.$$junctionSetMeta, childNode, nextJunctionPath]);
        }
      }
    }
  }

  return function parsePath(path, query) {
    var strippedPath = path.replace(/^\/|\/($|\?)/g, '');
    var branches = {};

    if (strippedPath === '') {
      return;
    }

    var serializedParamValues = [];
    var pathParts = strippedPath.split('/');
    var next = tree;
    var i = 0;
    while (i < pathParts.length) {
      var pathPart = pathParts[i++];
      var node = next[pathPart];

      if (!node && next[':']) {
        serializedParamValues.push(pathPart);
        node = next[':'];
      }

      if (!node) {
        return;
      }

      var _node = node,
          _branch = _node.branch,
          _childNode = _node.childNode,
          junctionPath = _node.junctionPath;

      next = _childNode;

      if ((!_branch || _branch.intermediate) && i === pathParts.length) {
        return;
      }
      if (!_branch) {
        continue;
      }

      var paramNames = _branch.pattern.paramNames;
      var serializedParams = {};
      for (var _j = 0, _len = paramNames.length; _j < _len; _j++) {
        serializedParams[paramNames[_j]] = serializedParamValues[_j];
      }
      serializedParamValues = [];

      var queryParts = {};
      for (var _i = 0, _len2 = _branch.queryKeys.length; _i < _len2; _i++) {
        var queryKey = _branch.queryKeys[_i];
        if (query[queryKey] !== undefined) {
          var value = query[queryKey];
          queryParts[queryKey] = value;
          serializedParams[queryKey] = value;
        }
      }

      branches[junctionPath] = {
        branchKey: _branch.key,
        serializedParams: serializedParams,
        routePath: pathParts.slice(0, i).join('/'),
        queryParts: queryParts
      };
    }

    return branches;
  };
}