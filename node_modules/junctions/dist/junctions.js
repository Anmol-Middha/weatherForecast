(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Junctions"] = factory();
	else
		root["Junctions"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createJunction = __webpack_require__(14);

	Object.defineProperty(exports, 'createJunction', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_createJunction).default;
	  }
	});

	var _createConverter = __webpack_require__(13);

	Object.defineProperty(exports, 'createConverter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_createConverter).default;
	  }
	});

	var _locationsEqual = __webpack_require__(16);

	Object.defineProperty(exports, 'locationsEqual', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_locationsEqual).default;
	  }
	});

	var _routesMatch = __webpack_require__(17);

	Object.defineProperty(exports, 'routesMatch', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_routesMatch).default;
	  }
	});

	var _TypeGuards = __webpack_require__(3);

	Object.defineProperty(exports, 'isJunction', {
	  enumerable: true,
	  get: function get() {
	    return _TypeGuards.isJunction;
	  }
	});
	Object.defineProperty(exports, 'isRoute', {
	  enumerable: true,
	  get: function get() {
	    return _TypeGuards.isRoute;
	  }
	});
	Object.defineProperty(exports, 'isLocatedRoute', {
	  enumerable: true,
	  get: function get() {
	    return _TypeGuards.isLocatedRoute;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createParamType = createParamType;
	exports.deserializeParams = deserializeParams;
	exports.serializeParams = serializeParams;
	exports.addDefaultParams = addDefaultParams;
	var nonEmptyStringSerialier = {
	  serialize: function serialize(x) {
	    return x || '';
	  },
	  deserialize: function deserialize(x) {
	    return x == '' ? null : x;
	  }
	};

	/**
	 * Define a parameter which is available for all Routes through a specific branch.
	 * 
	 * @param {Object}          options
	 * @param {function | any}  options.default     A default value, or function to generate one
	 * @param {boolean}         options.required    Throw an error if a route is created without this param
	 * @param {Serializer}      options.serializer  How to serialize/deserialize
	 */
	function createParamType() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var serializer = void 0;
	  if (options !== true && 'serializer' in options) {
	    if (!options.serializer || typeof options.serializer.serialize !== 'function' || typeof options.serializer.deserialize !== 'function') {
	      throw new Error('A junctions Serializer must specify serialize, deserialize');
	    }

	    serializer = {
	      serialize: options.serializer.serialize,
	      deserialize: options.serializer.deserialize
	    };
	  } else {
	    serializer = nonEmptyStringSerialier;
	  }

	  var param = {
	    default: options.default,
	    required: options.required || false,
	    serializer: serializer
	  };

	  return param;
	}

	function deserializeParams(paramTypes, params) {
	  var deserializedParams = {};
	  var keys = Object.keys(params);
	  for (var i = 0, len = keys.length; i < len; i++) {
	    var key = keys[i];
	    var serializer = paramTypes[key].serializer;
	    var serializedValue = params[key];
	    deserializedParams[key] = serializer.deserialize(decodeURIComponent(serializedValue));
	  }
	  return deserializedParams;
	}

	function serializeParams(paramTypes, params) {
	  var serializedParams = {};
	  var keys = Object.keys(params);
	  for (var i = 0, len = keys.length; i < len; i++) {
	    var key = keys[i];
	    var serializedValue = encodeURIComponent(paramTypes[key].serializer.serialize(params[key]));
	    if (serializedValue !== undefined) {
	      serializedParams[key] = serializedValue;
	    }
	  }
	  return serializedParams;
	}

	function addDefaultParams(paramTypes) {
	  var knownParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var paramKeys = Object.keys(knownParams);
	  var remainingParamKeys = Object.keys(paramTypes);
	  var paramsCopy = Object.assign({}, knownParams);

	  for (var i = 0, len = paramKeys.length; i < len; i++) {
	    var key = paramKeys[i];
	    var paramType = paramTypes[key];

	    if (!paramType) {
	      throw new Error('Could not create a route. A param with key \'' + key + '\' was specified, but this key is not listed in the corresponding Branche\'s params.');
	    }

	    remainingParamKeys.splice(remainingParamKeys.indexOf(key), 1);
	  }

	  for (var _i = 0, _len = remainingParamKeys.length; _i < _len; _i++) {
	    var _key = remainingParamKeys[_i];
	    var _paramType = paramTypes[_key];
	    var defaultParam = _paramType.default;
	    if (defaultParam) {
	      paramsCopy[_key] = typeof defaultParam == 'function' ? defaultParam() : defaultParam;
	    } else if (_paramType.required) {
	      throw new Error('Cannot create route without required key \'' + _key + '\'');
	    }
	  }

	  return paramsCopy;
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LocatedRoute = exports.Route = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.createRoute = createRoute;

	var _desugarNext = __webpack_require__(6);

	var _desugarNext2 = _interopRequireDefault(_desugarNext);

	var _getLocationFromRouteSet = __webpack_require__(7);

	var _getLocationFromRouteSet2 = _interopRequireDefault(_getLocationFromRouteSet);

	var _SearchUtils = __webpack_require__(8);

	var _Params = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Route = exports.Route = function () {
	  function Route(branch) {
	    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    _classCallCheck(this, Route);

	    this.childRouteSet = next;

	    this.branch = branch;
	    this.next = branch.next && (branch.next.$$junctionSetMeta.isSingle ? next.main : next);
	    this.data = branch.data;
	    this.key = branch.key;
	    this.params = params;
	  }

	  _createClass(Route, [{
	    key: 'locate',
	    value: function locate() {
	      throw new Error('You cannot access the \'locate\' function on routes created directly with Branch. Instead, use the \'link\' passed in via your component\'s props.');
	    }
	  }]);

	  return Route;
	}();

	var LocatedRoute = exports.LocatedRoute = function (_Route) {
	  _inherits(LocatedRoute, _Route);

	  function LocatedRoute(baseLocation, isRouteInPath, junctionPath, branch, params, next) {
	    _classCallCheck(this, LocatedRoute);

	    var _this = _possibleConstructorReturn(this, (LocatedRoute.__proto__ || Object.getPrototypeOf(LocatedRoute)).call(this, branch, params, next));

	    _this.baseLocation = baseLocation;
	    _this.isRouteInPath = isRouteInPath;
	    _this.junctionPath = junctionPath;

	    _this.locate = function () {
	      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
	        next[_key] = arguments[_key];
	      }

	      var location = next.length > 0 ? (0, _getLocationFromRouteSet2.default)(_this.baseLocation, _this.isRouteInPath, _this.junctionPath, _this.branch.next, next) : Object.assign({}, _this.baseLocation);

	      location.search = (0, _SearchUtils.createSearch)(location.query);
	      delete location.query;

	      return Object.freeze(location);
	    };

	    Object.freeze(_this);
	    return _this;
	  }

	  return LocatedRoute;
	}(Route);

	function createRoute(branch, params) {
	  for (var _len2 = arguments.length, next = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	    next[_key2 - 2] = arguments[_key2];
	  }

	  var desugaredNext = (0, _desugarNext2.default)(branch.next, next) || {};

	  var childKeys = Object.keys(desugaredNext);
	  for (var i = 0, len = childKeys.length; i < len; i++) {
	    var key = childKeys[i];
	    if (!branch.next[key]) {
	      throw new Error('A Route cannot be created with child key "' + key + '" which is not in the associated branch\'s next');
	    }
	    if (desugaredNext[key] && !(desugaredNext[key] instanceof Route)) {
	      throw new Error('A Route cannot be created with a non-Route child (see child key "' + key + '")');
	    }
	    if (desugaredNext[key] && !branch.next[key].$$junctionMeta.branchValues.includes(desugaredNext[key].branch)) {
	      throw new Error('A Route cannot be created with an unknown Branch type for key "' + key + '"');
	    }
	  }

	  return Object.freeze(new Route(branch, (0, _Params.addDefaultParams)(branch.paramTypes, params), desugaredNext));
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isJunction = isJunction;
	exports.isRoute = isRoute;
	exports.isLocatedRoute = isLocatedRoute;

	var _Routes = __webpack_require__(2);

	function isJunction(x) {
	  return x && !!x.$$junctionMeta;
	}
	function isRoute(x) {
	  return x instanceof _Routes.Route;
	}
	function isLocatedRoute(x) {
	  return x instanceof _Routes.LocatedRoute;
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.compilePattern = compilePattern;
	exports.formatPattern = formatPattern;
	function compilePattern(path, availableParamNames) {
	  if (/\/{2,}/.test(path)) {
	    throw new Error('Pattern "' + path + '" must not have adjacent "/" characters');
	  }
	  if (path[0] !== '/') {
	    throw new Error('Pattern "' + path + '" must start with the "/" character');
	  }
	  if (path[path.length - 1] === '/') {
	    throw new Error('Pattern "' + path + '" must not end with the "/" character');
	  }
	  if (!/^([A-Za-z0-9\$\-_\.+!*'\(\),\/]|\/:)+$/.test(path)) {
	    throw new Error('Pattern "' + path + '" must be composed of the / character and the URL-safe characters: A-Z a-z 0-9 $ - _ . + ! * \' ( ) ,');
	  }

	  var parts = path.split('/').slice(1);
	  var paramNames = parts.map(function (part, i) {
	    return part[0] == ':' && part.substr(1);
	  }).filter(function (x) {
	    return x;
	  });

	  for (var i = 0, len = paramNames.length; i < len; i++) {
	    if (availableParamNames.indexOf(paramNames[i]) === -1) {
	      throw new Error('Pattern "' + path + '" refers to an unknown param "' + paramNames[i] + '"');
	    }
	  }

	  return {
	    path: path,
	    parts: parts.map(function (part) {
	      return part[0] == ':' ? null : part;
	    }),
	    paramNames: paramNames
	  };
	}

	function formatPattern(pattern, params) {
	  var paramValues = [];
	  for (var i = 0, len = pattern.paramNames.length; i < len; i++) {
	    var name = pattern.paramNames[i];
	    var value = params[name];
	    if (!value) {
	      throw new Error('Required route param "' + name + '" was not found');
	    }
	    paramValues.push(value);
	  }
	  if (Object.keys(params).length > pattern.paramNames.length) {
	    throw new Error('Unknown params passed to route. Known params: ' + pattern.paramNames.join(', ') + '. Received params: ' + Object.keys(params).join(', ') + '.');
	  }
	  var parts = [];
	  for (var _i = 0, _len = pattern.parts.length; _i < _len; _i++) {
	    var part = pattern.parts[_i];
	    parts.push(part === null ? paramValues.shift() : part);
	  }
	  return parts.join('/');
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = JunctionSet;

	var _TypeGuards = __webpack_require__(3);

	var NODE_ENV = typeof process !== 'undefined' ? ("development") : 'development';

	function JunctionSet(options) {
	  if (options.$$junctionSetMeta) return options;

	  var isSingle = (0, _TypeGuards.isJunction)(options);
	  var primaryKey = isSingle || options.main ? 'main' : undefined;
	  var junctions = isSingle ? { main: options } : Object.assign({}, options);
	  var junctionKeys = Object.keys(junctions);
	  var junctionSetMeta = {
	    junctions: junctions,
	    junctionKeys: junctionKeys,
	    primaryKey: primaryKey,
	    isSingle: isSingle,
	    queryKeys: primaryKey ? junctions[primaryKey].$$junctionMeta.queryKeys : []
	  };
	  Object.defineProperty(junctions, '$$junctionSetMeta', { value: junctionSetMeta });
	  Object.freeze(junctions);

	  if (NODE_ENV !== 'production' && !isSingle) {
	    if (junctionKeys.length === 0) {
	      throw new Error('JunctionSet requires at least one Junction to be passed in');
	    }

	    for (var i = 0, len = junctionKeys.length; i < len; i++) {
	      var key = junctionKeys[i];

	      if (!(0, _TypeGuards.isJunction)(junctions[key])) {
	        throw new Error('An object was passed to JunctionSet which is not a Junction. See key "' + key + '"');
	      }
	      if (!/^[A-Za-z0-9_]+$/.test(key)) {
	        throw new Error('JunctionSet keys must only use the characters A-Z, a-z, 0-9 or _. See key "' + key + '"');
	      }
	    }
	  }

	  return junctions;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = desugarNext;

	var _Routes = __webpack_require__(2);

	function desugarNext(junctionSet, _next) {
	  if (_next.length && !(_next[0] == undefined && _next.length == 1)) {
	    if (!_next[0] || _next[0] instanceof _Routes.Route) {
	      // Find the junction keys of the passed in routes by looking through the available next of
	      // the passed in branch. Use these junction keys to build a route set.
	      if (!junctionSet) {
	        throw new Error('You attempted to pass child routes when no child junctions are available');
	      }

	      var next = _next.filter(function (child) {
	        return child;
	      });
	      var routeSet = {};

	      var childBranches = next.map(function (child) {
	        return child.branch;
	      });
	      var junctionKeys = junctionSet.$$junctionSetMeta.junctionKeys;

	      outer: for (var i = 0, len = junctionKeys.length; i < len; i++) {
	        var junctionKey = junctionKeys[i];
	        var junction = junctionSet[junctionKey];
	        var branchKeys = Object.keys(junction);
	        for (var j = 0, _len = branchKeys.length; j < _len; j++) {
	          var branch = junction[branchKeys[j]];
	          var branchIndex = childBranches.indexOf(branch);
	          if (branchIndex !== -1) {
	            routeSet[junctionKey] = next[branchIndex];
	            next.splice(branchIndex, 1);
	            childBranches.splice(branchIndex, 1);
	            if (next.length === 0) {
	              break outer;
	            }
	            continue outer;
	          }
	        }
	      }

	      if (next.length) {
	        throw new Error('A child route with key "' + next[0].branch.key + '" passed to createRoute could not be found in the passed-in branch\'s next.');
	      }

	      return routeSet;
	    } else {
	      return _next[0];
	    }
	  }
	  return {};
	}

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getLocationFromRouteSet;

	var _joinPaths = __webpack_require__(10);

	var _joinPaths2 = _interopRequireDefault(_joinPaths);

	var _PatternUtils = __webpack_require__(4);

	var _Params = __webpack_require__(1);

	var _desugarNext = __webpack_require__(6);

	var _desugarNext2 = _interopRequireDefault(_desugarNext);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getJunctionsLocation(isRouteInPath, parentJunctionPath, junctionSet, routeSet) {
	  var path = void 0;
	  var state = {};
	  var query = {};

	  var routeKeys = Object.keys(routeSet);
	  for (var i = 0, len = routeKeys.length; i < len; i++) {
	    var routeKey = routeKeys[i];
	    var junctionPath = parentJunctionPath.concat(routeKey);
	    var route = routeSet[routeKey];

	    if (route) {
	      var branch = route.branch;
	      var serializedParams = (0, _Params.serializeParams)(branch.paramTypes, route.params);

	      var isPrimaryRoute = isRouteInPath && junctionSet.$$junctionSetMeta.primaryKey == routeKey;
	      if (isPrimaryRoute) {
	        for (var _i = 0, _len = branch.queryKeys.length; _i < _len; _i++) {
	          var key = branch.queryKeys[_i];
	          var value = serializedParams[key];
	          if (value !== undefined && route.params[key] !== branch.paramTypes[key].default) {
	            query[key] = value;
	          }
	          delete serializedParams[key];
	        }

	        path = (0, _PatternUtils.formatPattern)(branch.pattern, serializedParams);
	      } else {
	        state[junctionPath.join('#')] = {
	          branchKey: branch.key,
	          serializedParams: serializedParams
	        };
	      }

	      if (branch.next) {
	        var childLocation = getJunctionsLocation(isPrimaryRoute, junctionPath, branch.next, route.childRouteSet);

	        Object.assign(state, childLocation.state);
	        Object.assign(query, childLocation.query);

	        if (childLocation.path) {
	          path += '/' + childLocation.path;
	        }
	      }
	    }
	  }

	  return { state: state, path: path, query: query };
	}

	// Convert routes into a Location object for the `history` package,
	// which is used to actually perform navigation.
	//
	// See https://github.com/mjackson/history
	function getLocationFromRouteSet(baseLocation, isRouteInPath, parentJunctionPath, junctionSet, routes) {
	  var routeSet = (0, _desugarNext2.default)(junctionSet, routes);

	  var _getJunctionsLocation = getJunctionsLocation(isRouteInPath, parentJunctionPath, junctionSet, routeSet),
	      state = _getJunctionsLocation.state,
	      path = _getJunctionsLocation.path,
	      query = _getJunctionsLocation.query;

	  var baseState = baseLocation.state || {};
	  var finalQuery = Object.assign({}, baseLocation.query, query);

	  return {
	    pathname: (0, _joinPaths2.default)(baseLocation.pathname, path),
	    hash: baseLocation.hash,
	    state: Object.assign({}, baseState, { $$junctions: Object.assign(state, baseState.$$junctions) }),
	    key: baseLocation.key,
	    query: finalQuery
	  };
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createSearch = createSearch;
	exports.parseSearch = parseSearch;
	function createSearch(query) {
	  var keys = Object.keys(query);

	  if (keys.length === 0) {
	    return '';
	  }

	  var parts = [];
	  for (var i = 0, len = keys.length; i < len; i++) {
	    var key = keys[i];
	    var value = query[key];
	    parts.push(value === '' ? key : key + '=' + encodeURIComponent(value));
	  }

	  return '?' + parts.join('&');
	}

	function parseSearch(search) {
	  if (!search || search[0] != '?') {
	    return {};
	  }

	  var query = {};
	  var queryParts = search.slice(1).split('&');
	  for (var i = 0, len = queryParts.length; i < len; i++) {
	    var x = queryParts[i].split('=');
	    query[x[0]] = x[1] ? decodeURIComponent(x[1]) : '';
	  }

	  return query;
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = hyphenize;
	// From https://github.com/ragingwind/hyphenize/blob/master/index.js
	// MIT Licensed
	// Copyright (c) ragingwind <ragingwind@gmail.com> (ragingwind.me)
	function hyphenize(str) {
	  return str.replace(/^(\W|-|\.)*/g, '').replace(/(|\W|\s)*$/g, '').replace(/([A-Z])([A-Z])([a-z0-9]){1,2}./g, function (match) {
	    return match.substr(0, 1) + '-' + match.substr(1).toLowerCase();
	  }).replace(/([a-z\d])([A-Z])/g, function (match, a, b) {
	    return a + (match.indexOf('-') >= 0 ? '' : '-') + b.toLowerCase();
	  }).replace(/([a-z0-9])([A-Z\d])([a-z0-9]){1,2}./g, function (match, a, b) {
	    return a.toLowerCase() + '-' + b;
	  }).replace(/ |\./g, '-').toLowerCase();
	}

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = joinPaths;
	function joinPaths(a, b) {
	  if (!b) {
	    return a;
	  }
	  if (a[a.length - 1] === '/') {
	    return a + b;
	  }
	  return a + '/' + b;
	}

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = objectsEqual;
	function objectsEqual(x, y, fn) {
	  if (x === y) return true;
	  if (!x && !y) return true;
	  if ((x || y) && (!x || !y)) return false;

	  var xKeys = Object.keys(x);
	  var yKeys = Object.keys(y);
	  var len = xKeys.length;

	  if (yKeys.length !== len) return false;

	  xKeys.sort();
	  yKeys.sort();

	  for (var i = 0; i < len; i++) {
	    if (xKeys[i] != yKeys[i]) return false;
	  }
	  for (var _i = 0; _i < len; _i++) {
	    var key = xKeys[_i];
	    if (fn ? !fn(x[key], y[key]) : x[key] !== y[key]) return false;
	  }

	  return true;
	}

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	exports.createPathParser = createPathParser;
	function createPathParser(junctionSet) {
	  var tree = {};
	  var queue = [[junctionSet.$$junctionSetMeta, tree, []]];
	  while (queue.length) {
	    var _queue$shift = queue.shift(),
	        _queue$shift2 = _slicedToArray(_queue$shift, 3),
	        junctionSetMetaNode = _queue$shift2[0],
	        treeNode = _queue$shift2[1],
	        junctionPath = _queue$shift2[2];

	    var primaryJunctionKey = junctionSetMetaNode.primaryKey;

	    if (primaryJunctionKey) {
	      var primaryJunction = junctionSetMetaNode.junctions[primaryJunctionKey];
	      var branchKeys = primaryJunction.$$junctionMeta.branchKeys;
	      var nextJunctionPath = junctionPath.concat(primaryJunctionKey);

	      for (var i = 0, len = branchKeys.length; i < len; i++) {
	        var branch = primaryJunction[branchKeys[i]];
	        var parts = branch.pattern.parts;
	        var finalIndex = parts.length - 1;
	        var intermediateNode = treeNode;
	        for (var j = 0; j < finalIndex; j++) {
	          var part = parts[j] || ':';
	          if (!intermediateNode[part]) {
	            intermediateNode[part] = { childNode: {} };
	          } else if (intermediateNode[part].branch) {
	            throw new Error('Conflicting paths');
	          }
	          intermediateNode = intermediateNode[part].childNode;
	        }
	        var finalPart = parts[finalIndex] || ':';
	        var childNode = {};
	        intermediateNode[finalPart] = {
	          branch: branch,
	          childNode: childNode,
	          junctionPath: nextJunctionPath.join('#')
	        };
	        if (branch.next) {
	          queue.push([branch.next.$$junctionSetMeta, childNode, nextJunctionPath]);
	        }
	      }
	    }
	  }

	  return function parsePath(path, query) {
	    var strippedPath = path.replace(/^\/|\/($|\?)/g, '');
	    var branches = {};

	    if (strippedPath === '') {
	      return;
	    }

	    var serializedParamValues = [];
	    var pathParts = strippedPath.split('/');
	    var next = tree;
	    var i = 0;
	    while (i < pathParts.length) {
	      var pathPart = pathParts[i++];
	      var node = next[pathPart];

	      if (!node && next[':']) {
	        serializedParamValues.push(pathPart);
	        node = next[':'];
	      }

	      if (!node) {
	        return;
	      }

	      var _node = node,
	          _branch = _node.branch,
	          _childNode = _node.childNode,
	          junctionPath = _node.junctionPath;

	      next = _childNode;

	      if ((!_branch || _branch.intermediate) && i === pathParts.length) {
	        return;
	      }
	      if (!_branch) {
	        continue;
	      }

	      var paramNames = _branch.pattern.paramNames;
	      var serializedParams = {};
	      for (var _j = 0, _len = paramNames.length; _j < _len; _j++) {
	        serializedParams[paramNames[_j]] = serializedParamValues[_j];
	      }
	      serializedParamValues = [];

	      var queryParts = {};
	      for (var _i = 0, _len2 = _branch.queryKeys.length; _i < _len2; _i++) {
	        var queryKey = _branch.queryKeys[_i];
	        if (query[queryKey] !== undefined) {
	          var value = query[queryKey];
	          queryParts[queryKey] = value;
	          serializedParams[queryKey] = value;
	        }
	      }

	      branches[junctionPath] = {
	        branchKey: _branch.key,
	        serializedParams: serializedParams,
	        routePath: pathParts.slice(0, i).join('/'),
	        queryParts: queryParts
	      };
	    }

	    return branches;
	  };
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createConverter;

	var _getLocationFromRouteSet = __webpack_require__(7);

	var _getLocationFromRouteSet2 = _interopRequireDefault(_getLocationFromRouteSet);

	var _getRouteSetFromLocation = __webpack_require__(15);

	var _getRouteSetFromLocation2 = _interopRequireDefault(_getRouteSetFromLocation);

	var _PathParser = __webpack_require__(12);

	var _hyphenize = __webpack_require__(9);

	var _hyphenize2 = _interopRequireDefault(_hyphenize);

	var _JunctionSet = __webpack_require__(5);

	var _JunctionSet2 = _interopRequireDefault(_JunctionSet);

	var _SearchUtils = __webpack_require__(8);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createConverter(junctionSetOptions) {
	  var baseLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { pathname: '/' };

	  var junctionSet = (0, _JunctionSet2.default)(junctionSetOptions);

	  var parsePath = (0, _PathParser.createPathParser)(junctionSet);
	  var baseLocationWithQuery = Object.assign({}, baseLocation, { query: (0, _SearchUtils.parseSearch)(baseLocation.search) });

	  return {
	    locate: function locate() {
	      for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {
	        next[_key] = arguments[_key];
	      }

	      if (next.length === 0) return baseLocation;

	      var location = (0, _getLocationFromRouteSet2.default)(baseLocationWithQuery, true, [], junctionSet, next);
	      location.search = (0, _SearchUtils.createSearch)(location.query);
	      delete location.query;
	      return Object.freeze(location);
	    },
	    route: function route(location) {
	      var locationWithQuery = Object.assign({}, location, { query: (0, _SearchUtils.parseSearch)(location.search) });
	      return (0, _getRouteSetFromLocation2.default)(parsePath, baseLocationWithQuery, junctionSet, locationWithQuery);
	    }
	  };
	}

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createJunction;

	var _hyphenize = __webpack_require__(9);

	var _hyphenize2 = _interopRequireDefault(_hyphenize);

	var _PatternUtils = __webpack_require__(4);

	var _JunctionSet = __webpack_require__(5);

	var _JunctionSet2 = _interopRequireDefault(_JunctionSet);

	var _Params = __webpack_require__(1);

	var _Routes = __webpack_require__(2);

	var _TypeGuards = __webpack_require__(3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createDefaultPattern(key, paramTypes) {
	  var id = (0, _hyphenize2.default)(key);
	  var branchParamKeys = Object.keys(paramTypes);
	  var paramNames = branchParamKeys.filter(function (key) {
	    var param = paramTypes[key];
	    return param.required || param.default;
	  });

	  return {
	    id: id,
	    parts: [id].concat(paramNames.map(function (x) {
	      return null;
	    })),
	    paramNames: paramNames
	  };
	}

	function createJunction(branchOptions) {
	  var branches = {};
	  var queryKeys = {};
	  var branchKeys = Object.keys(branchOptions);
	  var defaultKey = void 0;

	  if (branchKeys.length === 0) {
	    throw new Error('Junction requires at least one BranchTemplate to be passed in');
	  }

	  if (branchKeys.createRoute !== undefined) {
	    throw new Error('You cannot supply a branch named `createRoute` to `createJunction`, as it is a reserved name.');
	  }

	  var _loop = function _loop(i, len) {
	    var key = branchKeys[i];

	    if (key.indexOf('#') !== -1) {
	      throw new Error('Junction keys may not use the character \'#\', but key was named "' + key + '".');
	    }

	    var options = branchOptions[key] === true ? {} : branchOptions[key];

	    var paramTypes = {};
	    var paramNames = options.paramTypes ? Object.keys(options.paramTypes) : [];
	    for (var _i = 0, _len2 = paramNames.length; _i < _len2; _i++) {
	      var paramName = paramNames[_i];
	      if (!/^[A-Za-z0-9_]+$/.test(paramName)) {
	        throw new Error('Branch param keys must only use the characters A-Z, a-z, 0-9 or _, but key was named "' + paramName + '".');
	      }
	      paramTypes[paramName] = (0, _Params.createParamType)(options.paramTypes[paramName]);
	    }

	    var pattern = options.path ? (0, _PatternUtils.compilePattern)(options.path, paramNames) : createDefaultPattern(key, paramTypes);

	    if (!!options.intermediate && !options.next) {
	      throw new Error('You cannot set a branch as intermediate without providing a `next` junction.');
	    }

	    var branch = {
	      next: options.next && (0, _JunctionSet2.default)(options.next),
	      data: Object.freeze(options.data || {}),
	      intermediate: !!options.intermediate,
	      default: !!options.default,
	      key: key,
	      paramTypes: paramTypes,
	      pattern: pattern,
	      queryKeys: Object.keys(paramTypes).filter(function (x) {
	        return !pattern.paramNames.includes(x);
	      })
	    };

	    if ('next' in options && options.next === undefined) {
	      throw new Error('Branch "' + key + '" was given a next propery, but its value was "undefined"');
	    }

	    if (branch.next) {
	      (function () {
	        var childQueryKeys = branch.next.$$junctionSetMeta.queryKeys;
	        var duplicateKey = branch.queryKeys.find(function (x) {
	          return childQueryKeys.includes(x);
	        });
	        if (duplicateKey) {
	          throw new Error('The param "' + duplicateKey + '" was specified in branch "' + key + '" as well as one of its child branches');
	        }
	      })();
	    }

	    if (branch.default) {
	      if (defaultKey) {
	        throw new Error('Branch "' + key + '" was specified as default, when branch "' + junctionMeta.defaultKey + '" was already used as default.');
	      }
	      defaultKey = key;
	    }

	    for (var _i2 = 0, _len3 = branch.queryKeys.length; _i2 < _len3; _i2++) {
	      queryKeys[branch.queryKeys[_i2]] = true;
	    }

	    branches[key] = Object.freeze(branch);
	  };

	  for (var i = 0, len = branchKeys.length; i < len; i++) {
	    _loop(i, len);
	  }

	  var patternIds = branchKeys.map(function (key) {
	    return branches[key].pattern.parts.map(function (part) {
	      return part === null ? ':' : part;
	    }).concat('').join('/');
	  }).sort();
	  for (var i = 1, len = patternIds.length; i < len; i++) {
	    if (patternIds[i].indexOf(patternIds[i - 1]) === 0) {
	      throw new Error('Two branches have paths "' + patternIds[i - 1] + '" and "' + patternIds[i] + '" that match the same URLs!');
	    }
	  }

	  var junctionMeta = {
	    branches: branches,
	    branchKeys: branchKeys,
	    branchValues: branchKeys.map(function (k) {
	      return branches[k];
	    }),
	    defaultKey: defaultKey,
	    queryKeys: Object.keys(queryKeys)
	  };

	  Object.defineProperty(branches, '$$junctionMeta', { value: junctionMeta });
	  Object.defineProperty(branches, 'createRoute', {
	    value: function value(branchKey, params) {
	      for (var _len = arguments.length, next = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        next[_key - 2] = arguments[_key];
	      }

	      var branch = branches[branchKey];

	      if (branch === undefined) {
	        throw new Error('Could not create route as the key "' + branchKey + '" is not known.');
	      }

	      return _Routes.createRoute.apply(undefined, [branch, params].concat(next));
	    }
	  });

	  return Object.freeze(branches);
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getRouteSetFromLocation;

	var _Routes = __webpack_require__(2);

	var _Params = __webpack_require__(1);

	var _omit = __webpack_require__(18);

	var _omit2 = _interopRequireDefault(_omit);

	var _joinPaths = __webpack_require__(10);

	var _joinPaths2 = _interopRequireDefault(_joinPaths);

	var _PatternUtils = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function getRouteBaseLocation(parentBaseLocation, isRouteInPath, junctionPath, branch, params) {
	  if (isRouteInPath) {
	    var queryParams = {};
	    for (var i = 0, len = branch.queryKeys.length; i < len; i++) {
	      var key = branch.queryKeys[i];
	      var value = params[key];
	      if (value !== undefined && value !== branch.paramTypes[key].default) {
	        queryParams[key] = value;
	      }
	    }

	    var serializedQuery = (0, _Params.serializeParams)(branch.paramTypes, queryParams);
	    var serializedPathParams = (0, _Params.serializeParams)(branch.paramTypes, (0, _omit2.default)(params, branch.queryKeys));

	    var query = Object.assign({}, serializedQuery, parentBaseLocation.query);
	    return {
	      pathname: (0, _joinPaths2.default)(parentBaseLocation.pathname, (0, _PatternUtils.formatPattern)(branch.pattern, serializedPathParams)),
	      query: query,
	      hash: parentBaseLocation.hash,
	      state: parentBaseLocation.state,
	      key: parentBaseLocation.key
	    };
	  } else {
	    var baseState = parentBaseLocation.state || {};

	    return {
	      pathname: parentBaseLocation.pathname,
	      query: parentBaseLocation.query,
	      hash: parentBaseLocation.hash,
	      state: Object.assign({}, baseState, {
	        $$junctions: Object.assign({}, baseState.$$junctions, _defineProperty({}, junctionPath.join('#'), {
	          branchKey: branch.key,
	          serializedParams: (0, _Params.serializeParams)(branch.paramTypes, params)
	        }))
	      }),
	      key: parentBaseLocation.key
	    };
	  }
	}

	function createLocatedRouteSetFor(junctionSetMeta, parentRouteOptions) {
	  var routeSetOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var routeSet = {};
	  var junctionKeys = junctionSetMeta.junctionKeys;

	  for (var i = 0, len = junctionKeys.length; i < len; i++) {
	    var key = junctionKeys[i];

	    if (routeSetOptions[key]) {
	      var routeOptions = routeSetOptions[key];
	      var childJunctionSet = junctionSetMeta.junctions[key].$$junctionMeta.branches[routeOptions.branch.key].next;
	      var routeNext = childJunctionSet && createLocatedRouteSetFor(childJunctionSet.$$junctionSetMeta, routeOptions, routeOptions.next);

	      routeSet[key] = new _Routes.LocatedRoute(routeOptions.baseLocation, routeOptions.isRouteInPath, routeOptions.junctionPath, routeOptions.branch, routeOptions.params, routeNext);
	    } else {
	      var junctionMeta = junctionSetMeta.junctions[key].$$junctionMeta;

	      if (junctionMeta.defaultKey) {
	        var branch = junctionMeta.branches[junctionMeta.defaultKey];
	        var routeJunctionPath = parentRouteOptions.junctionPath.concat(key);
	        var isBranchRouteInPath = parentRouteOptions.isRouteInPath && key == junctionSetMeta.primaryKey;
	        var routeParams = (0, _Params.addDefaultParams)(branch.paramTypes);
	        var routeBaseLocation = getRouteBaseLocation(parentRouteOptions.baseLocation, parentRouteOptions.isRouteInPath, routeJunctionPath, branch, routeParams);

	        var defaultRouteOptions = {
	          baseLocation: routeBaseLocation,
	          isRouteInPath: isBranchRouteInPath,
	          junctionPath: routeJunctionPath,
	          branch: branch,
	          params: routeParams
	        };

	        var _routeNext = branch.next && createLocatedRouteSetFor(branch.next.$$junctionSetMeta, defaultRouteOptions);

	        routeSet[key] = new _Routes.LocatedRoute(routeBaseLocation, isBranchRouteInPath, routeJunctionPath, branch, routeParams, _routeNext);
	      }
	    }
	  }

	  return routeSet;
	}

	function getRouteSetFromLocation(parsePath, baseLocation, junctionSet, location) {
	  // TODO:
	  // - memoize by object equality of the previous invocation (only need memory size of 1)

	  // TODO:
	  // - if junctionSet's main junction is a hostname junction, merge the hostname into the
	  //   beginning of the location path

	  var basePath = baseLocation.pathname || '';

	  var locationState = location.state || {};

	  var path = void 0;
	  if (basePath) {
	    if (location.pathname.indexOf(basePath) === -1) {
	      throw new Error('The specified "location" and "baseLocation" don\'t match. Expected location to start with "' + basePath + '" but instead found "' + location.path + '".');
	    }

	    path = location.pathname.substr(basePath.length);
	  } else {
	    path = location.pathname || '';
	  }

	  var query = (0, _omit2.default)(location.query, Object.keys(baseLocation.query));
	  var pathState = {};
	  if (path !== '') {
	    pathState = parsePath(path, query);
	    if (!pathState) {
	      return;
	    }
	  }

	  var state = Object.assign({}, locationState.$$junctions, pathState);
	  var routeSetOptions = {};
	  var baseSet = {};
	  var rootParentOptions = {
	    baseLocation: baseLocation,
	    isRouteInPath: true,
	    junctionPath: []
	  };

	  var walkOrder = Object.keys(state).sort();

	  if (walkOrder.length === 0) {
	    // We have a valid path but no state, so use defaults on the root junctions
	    var _routeSet = createLocatedRouteSetFor(junctionSet.$$junctionSetMeta, rootParentOptions, routeSetOptions);

	    // Emit null insteaed of undefined to indicate that it is still a known route
	    return junctionSet.$$junctionSetMeta.isSingle ? _routeSet.main || null : _routeSet;
	  }

	  var junctionPaths = walkOrder.map(function (key) {
	    return key.split('#');
	  });
	  for (var i = 0, len = walkOrder.length; i < len; i++) {
	    var stateKey = walkOrder[i];
	    var junctionPath = junctionPaths[i];
	    var key = junctionPath.slice(-1);

	    var routeSetOptionsNode = routeSetOptions;
	    var junctionSetNode = junctionSet;
	    for (var _i = 0, _len = junctionPath.length - 1; _i < _len; _i++) {
	      var _key = junctionPath[_i];
	      var junctionNode = junctionSetNode[_key];
	      var routeOptionsNode = routeSetOptionsNode[_key];
	      routeSetOptionsNode = routeOptionsNode.next;
	      junctionSetNode = junctionNode[routeOptionsNode.branch.key].next;
	    }

	    var junction = junctionSetNode[key];
	    var _state$stateKey = state[stateKey],
	        branchKey = _state$stateKey.branchKey,
	        serializedParams = _state$stateKey.serializedParams,
	        routePath = _state$stateKey.routePath;

	    var branch = junction[branchKey];
	    var params = (0, _Params.addDefaultParams)(branch.paramTypes, (0, _Params.deserializeParams)(branch.paramTypes, serializedParams));
	    var isRouteInPath = !!routePath;

	    // Copy all state paths except our next
	    var newBaseState = {};
	    var newBaseQuery = {};
	    var newBasePath = basePath;
	    var j = 0;
	    while (j < i) {
	      var _stateKey = walkOrder[j];
	      // Only state keys returned by the path parser have a `routePath` attribute,
	      // so we can use these to build our basePath
	      if (state[_stateKey].routePath) {
	        newBasePath = (0, _joinPaths2.default)(basePath, state[_stateKey].routePath);

	        if (state[_stateKey].queryParts) {
	          Object.assign(newBaseQuery, state[_stateKey].queryParts);
	        }
	      } else {
	        newBaseState[_stateKey] = state[_stateKey];
	      }
	      j++;
	    }
	    while (j < len && junctionPaths[j].length >= junctionPath.length) {
	      j++;
	    }
	    while (j < len) {
	      var _stateKey2 = walkOrder[j];
	      newBaseState[_stateKey2] = state[_stateKey2];
	      j++;
	    }

	    var routeParentBaseLocation = {
	      pathname: newBasePath,
	      hash: baseLocation.hash,
	      state: Object.assign({}, baseLocation.state, {
	        $$junctions: newBaseState
	      }),
	      query: Object.assign({}, baseLocation.query, newBaseQuery)
	    };

	    routeSetOptionsNode[key] = {
	      baseLocation: getRouteBaseLocation(routeParentBaseLocation, isRouteInPath, junctionPath, branch, params),
	      isRouteInPath: isRouteInPath,
	      junctionPath: junctionPath,
	      branch: branch,
	      params: params,
	      next: {}
	    };
	  }

	  var routeSet = createLocatedRouteSetFor(junctionSet.$$junctionSetMeta, rootParentOptions, routeSetOptions);

	  // Emit null insteaed of undefined to indicate that it is still a known route
	  return junctionSet.$$junctionSetMeta.isSingle ? routeSet.main || null : routeSet;
	}

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = locationsEqual;

	var _objectsEqual = __webpack_require__(11);

	var _objectsEqual2 = _interopRequireDefault(_objectsEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function locationsEqual(x, y) {
	  if (x === y) return true;

	  return x.pathname == y.pathname && x.search == y.search && (0, _objectsEqual2.default)(x.state && x.state.$$junctions || {}, y.state && y.state.$$junctions || {}, function (x, y) {
	    return x.branchKey == y.branchKey && (0, _objectsEqual2.default)(x.serializedParams, y.serializedParams);
	  });
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = routesMatch;

	var _TypeGuards = __webpack_require__(3);

	var _Params = __webpack_require__(1);

	var _objectsEqual = __webpack_require__(11);

	var _objectsEqual2 = _interopRequireDefault(_objectsEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function routesMatch(specificRoute, partialRoute) {
	  var exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	  var a = specificRoute;
	  var b = partialRoute;

	  if (!a && !b) {
	    return true;
	  }
	  if (!a || !b) {
	    return false;
	  }

	  if ((0, _TypeGuards.isRoute)(a) || (0, _TypeGuards.isRoute)(b)) {
	    if (!(0, _TypeGuards.isRoute)(a) || !(0, _TypeGuards.isRoute)(b)) {
	      return false;
	    }

	    if (a.branch !== b.branch) {
	      return false;
	    }

	    var branch = a.branch;

	    if (!(0, _objectsEqual2.default)((0, _Params.serializeParams)(branch.paramTypes, a.params), (0, _Params.serializeParams)(branch.paramTypes, b.params))) {
	      return false;
	    }

	    return !branch.next || !exact && specificRoute.next && !partialRoute.next || routesMatch(a.next, b.next);
	  }

	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== 'object') {
	    return false;
	  }

	  return (0, _objectsEqual2.default)(a, b, routesMatch);
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = omit;
	function omit(obj, params) {
	  var selected = {};
	  var keys = Object.keys(obj);
	  for (var i = 0, len = keys.length; i < len; i++) {
	    var key = keys[i];
	    if (params.indexOf(key) === -1) {
	      selected[key] = obj[key];
	    }
	  }
	  return selected;
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }
/******/ ])
});
;