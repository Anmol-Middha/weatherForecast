'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createJunction;

var _hyphenize = require('./utils/hyphenize');

var _hyphenize2 = _interopRequireDefault(_hyphenize);

var _PatternUtils = require('./utils/PatternUtils');

var _JunctionSet = require('./JunctionSet');

var _JunctionSet2 = _interopRequireDefault(_JunctionSet);

var _Params = require('./Params');

var _Routes = require('./Routes');

var _TypeGuards = require('./TypeGuards');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createDefaultPattern(key, paramTypes) {
  var id = (0, _hyphenize2.default)(key);
  var branchParamKeys = Object.keys(paramTypes);
  var paramNames = branchParamKeys.filter(function (key) {
    var param = paramTypes[key];
    return param.required || param.default;
  });

  return {
    id: id,
    parts: [id].concat(paramNames.map(function (x) {
      return null;
    })),
    paramNames: paramNames
  };
}

function createJunction(branchOptions) {
  var branches = {};
  var queryKeys = {};
  var branchKeys = Object.keys(branchOptions);
  var defaultKey = void 0;

  if (branchKeys.length === 0) {
    throw new Error('Junction requires at least one BranchTemplate to be passed in');
  }

  if (branchKeys.createRoute !== undefined) {
    throw new Error('You cannot supply a branch named `createRoute` to `createJunction`, as it is a reserved name.');
  }

  var _loop = function _loop(i, len) {
    var key = branchKeys[i];

    if (key.indexOf('#') !== -1) {
      throw new Error('Junction keys may not use the character \'#\', but key was named "' + key + '".');
    }

    var options = branchOptions[key] === true ? {} : branchOptions[key];

    var paramTypes = {};
    var paramNames = options.paramTypes ? Object.keys(options.paramTypes) : [];
    for (var _i = 0, _len2 = paramNames.length; _i < _len2; _i++) {
      var paramName = paramNames[_i];
      if (!/^[A-Za-z0-9_]+$/.test(paramName)) {
        throw new Error('Branch param keys must only use the characters A-Z, a-z, 0-9 or _, but key was named "' + paramName + '".');
      }
      paramTypes[paramName] = (0, _Params.createParamType)(options.paramTypes[paramName]);
    }

    var pattern = options.path ? (0, _PatternUtils.compilePattern)(options.path, paramNames) : createDefaultPattern(key, paramTypes);

    if (!!options.intermediate && !options.next) {
      throw new Error('You cannot set a branch as intermediate without providing a `next` junction.');
    }

    var branch = {
      next: options.next && (0, _JunctionSet2.default)(options.next),
      data: Object.freeze(options.data || {}),
      intermediate: !!options.intermediate,
      default: !!options.default,
      key: key,
      paramTypes: paramTypes,
      pattern: pattern,
      queryKeys: Object.keys(paramTypes).filter(function (x) {
        return !pattern.paramNames.includes(x);
      })
    };

    if ('next' in options && options.next === undefined) {
      throw new Error('Branch "' + key + '" was given a next propery, but its value was "undefined"');
    }

    if (branch.next) {
      (function () {
        var childQueryKeys = branch.next.$$junctionSetMeta.queryKeys;
        var duplicateKey = branch.queryKeys.find(function (x) {
          return childQueryKeys.includes(x);
        });
        if (duplicateKey) {
          throw new Error('The param "' + duplicateKey + '" was specified in branch "' + key + '" as well as one of its child branches');
        }
      })();
    }

    if (branch.default) {
      if (defaultKey) {
        throw new Error('Branch "' + key + '" was specified as default, when branch "' + junctionMeta.defaultKey + '" was already used as default.');
      }
      defaultKey = key;
    }

    for (var _i2 = 0, _len3 = branch.queryKeys.length; _i2 < _len3; _i2++) {
      queryKeys[branch.queryKeys[_i2]] = true;
    }

    branches[key] = Object.freeze(branch);
  };

  for (var i = 0, len = branchKeys.length; i < len; i++) {
    _loop(i, len);
  }

  var patternIds = branchKeys.map(function (key) {
    return branches[key].pattern.parts.map(function (part) {
      return part === null ? ':' : part;
    }).concat('').join('/');
  }).sort();
  for (var i = 1, len = patternIds.length; i < len; i++) {
    if (patternIds[i].indexOf(patternIds[i - 1]) === 0) {
      throw new Error('Two branches have paths "' + patternIds[i - 1] + '" and "' + patternIds[i] + '" that match the same URLs!');
    }
  }

  var junctionMeta = {
    branches: branches,
    branchKeys: branchKeys,
    branchValues: branchKeys.map(function (k) {
      return branches[k];
    }),
    defaultKey: defaultKey,
    queryKeys: Object.keys(queryKeys)
  };

  Object.defineProperty(branches, '$$junctionMeta', { value: junctionMeta });
  Object.defineProperty(branches, 'createRoute', {
    value: function value(branchKey, params) {
      for (var _len = arguments.length, next = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        next[_key - 2] = arguments[_key];
      }

      var branch = branches[branchKey];

      if (branch === undefined) {
        throw new Error('Could not create route as the key "' + branchKey + '" is not known.');
      }

      return _Routes.createRoute.apply(undefined, [branch, params].concat(next));
    }
  });

  return Object.freeze(branches);
}